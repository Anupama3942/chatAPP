<!DOCTYPE html>
<html>
<head>
    <title>CrypTalk - Secure DOS Chat</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://unpkg.com/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/xterm@5.3.0/css/xterm.css">
    <style>
        body { 
            background: black; 
            margin: 0; 
            padding: 20px;
            font-family: 'Courier New', monospace;
            color: lime;
            overflow: hidden;
        }
        .terminal-container {
            border: 2px solid lime;
            padding: 10px;
            max-width: 1000px;
            margin: 0 auto;
            height: 90vh;
        }
        .status-bar {
            border-bottom: 1px solid lime;
            padding: 5px;
            margin-bottom: 10px;
        }
        #terminal {
            height: calc(100% - 60px);
            width: 100%;
        }
        .help-text {
            color: yellow;
            font-size: 12px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <div class="status-bar">
            <strong>CrypTalk v2.0</strong> | User: {{ username }} | 
            <span id="online-count">0 users online</span> |
            <a href="/logout" style="color:lime;">Logout</a>
        </div>
        <div id="terminal"></div>
        <div class="help-text">ðŸ’¡ Type your message and press ENTER to send. Online users will appear above.</div>
    </div>

    <script>
        const userId = "{{ user_id }}";
        const userEmail = "{{ username }}";
        
        // Initialize terminal
        const term = new Terminal({
            cursorBlink: true,
            theme: {
                background: 'black',
                foreground: 'lime'
            },
            fontSize: 14,
            fontFamily: 'Courier New'
        });
        
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(document.getElementById('terminal'));
        fitAddon.fit();

        // Socket.io connection
        const socket = io();

        // Store online users
        const onlineUsersMap = new Map();
        let currentInput = '';

        // E2EE Crypto functions
        async function generateKeyPair() {
            try {
                const keyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "ECDH",
                        namedCurve: "P-256"
                    },
                    true,
                    ["deriveKey", "deriveBits"]
                );
                return keyPair;
            } catch (error) {
                console.error("Key generation failed:", error);
                return null;
            }
        }

        async function exportPublicKey(key) {
            const exported = await window.crypto.subtle.exportKey("spki", key);
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        }

        // User registration with public key
        async function registerUser() {
            try {
                const keyPair = await generateKeyPair();
                if (!keyPair) {
                    term.writeln('\r\nâŒ Failed to generate encryption keys');
                    return;
                }
                
                const publicKey = await exportPublicKey(keyPair.publicKey);
                
                // Register with server
                socket.emit("register", {
                    user_id: userId,
                    email: userEmail,
                    public_key: publicKey
                });
                
                window.userKeyPair = keyPair;
                term.writeln('\r\nðŸ” Encryption keys generated and registered');
                term.writeln('ðŸ’¬ Type messages and press ENTER to send');
                term.writeln('ðŸ“± Open another browser window to test with multiple users\r\n');
                term.write('> ');
                
            } catch (error) {
                term.writeln('\r\nâŒ Key generation failed: ' + error.message);
                term.write('> ');
            }
        }

        // Socket event handlers
        socket.on("user_list", function(users) {
            document.getElementById('online-count').textContent = `${users.length} users online`;
            
            // Update online users map
            onlineUsersMap.clear();
            users.forEach(user => {
                onlineUsersMap.set(user.user_id, user);
            });
            
            // Show online users in terminal
            if (users.length > 0) {
                term.write('\x1b[2K\r'); // Clear current line
                term.write(`ðŸ‘¥ Online: ${users.map(u => u.email).join(', ')}`);
                term.write('\r\n> ' + currentInput);
            }
        });

        socket.on("private_message", async function(data) {
            term.writeln(`\r\nðŸ“¨ ${data.from_email}: [Encrypted message received]`);
            term.writeln('   ðŸ” Message is encrypted - decryption would happen here');
            term.write('> ' + currentInput);
        });

        socket.on("connect", function() {
            term.writeln('âœ… Connected to server');
            registerUser();
        });

        socket.on("disconnect", function() {
            term.writeln('\r\nâŒ Disconnected from server');
        });

        // Terminal input handling
        term.onData(function(data) {
            if (data === '\r') { // Enter key - send message
                if (currentInput.trim()) {
                    sendMessage(currentInput);
                    currentInput = '';
                    term.write('\r\n> ');
                }
            } else if (data === '\x7f') { // Backspace
                if (currentInput.length > 0) {
                    currentInput = currentInput.slice(0, -1);
                    term.write('\b \b');
                }
            } else if (data === '\u0003') { // Ctrl+C
                term.writeln('\r\n^C\r\nType "exit" to logout or continue chatting');
                term.write('> ' + currentInput);
            } else if (data.charCodeAt(0) >= 32) { // Printable characters
                currentInput += data;
                term.write(data);
            }
        });

        function sendMessage(message) {
            const onlineUsers = Array.from(onlineUsersMap.values());
            const otherUsers = onlineUsers.filter(u => u.user_id !== userId);
            
            if (otherUsers.length > 0) {
                const targetUser = otherUsers[0]; // Send to first online user
                
                // For now, send plain text until we fix encryption
                socket.emit("private_message", {
                    to_user_id: targetUser.user_id,
                    ciphertext: message, // This should be encrypted in final version
                    iv: "temp_iv" // This should be proper IV in final version
                });
                
                term.writeln(`\r\nðŸ“¤ You â†’ ${targetUser.email}: ${message}`);
            } else {
                term.writeln('\r\nâŒ No other users online to send message to');
            }
        }

        // Initialize
        term.writeln('ðŸš€ CrypTalk v2.0 - Secure E2EE Chat');
        term.writeln('ðŸ”Œ Connecting to server...');

        // Handle window resize
        window.addEventListener('resize', () => {
            fitAddon.fit();
        });

        // Focus terminal on click
        term.focus();
    </script>
</body>
</html>